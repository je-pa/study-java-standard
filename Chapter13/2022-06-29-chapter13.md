# 쓰레드 thread

## 프로세스
- 실행 중인 프로그램
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.
    ![img.png](images/program&process.png)
- 프로그램 수행 시 필요한 자원(데이터,메모리 등)과 쓰레드(최소 하나 이상)로 구성
    - 자원을 이용해서 작업 수행하는 것이 쓰레드!
    
    > ### 싱글쓰레드(single-threaded process) / 멀티쓰레드(multi-threaded process)
    > ![img.png](images/multi-threaded-process.png)
    > - 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스' 라고 한다
    > > **❓ 프로세스가 가질 수 있는 쓰레드 개수는 제한이 있을까요?**</br></br>
        제한되어 있지 않습니다! 
        </br>다만, 쓰레드는 작업을 수행하는데 메모리 공간(호출스택)이 필요합니다.
        </br>따라서 프로세스의 메모리 한계에 따른 개수 제한이 있다고 볼 수 있습니다.
        </br></br>(실제로는 프로세스의 메모리 한계에 다를 정도로 많은 쓰레드를 생성하는 일은 없어 걱정하지 않아도 된다고 합니다:)

## 멀티프로세스(멀티태스킹,다중작업) vs 멀티쓰레드(멀티 쓰레딩)
- 멀티태스킹 : 동시에 여러 프로세스를 실행시키는 것
- 멀티쓰레딩 : 하나의 프로세스 내에 동시에 여러 쓰레드를 실행시키는 것
  > 멀티태스킹이 가능함으로써 프로그램을 다운받으면서 웹서핑을 동시에 할 수 있게 된다.

  > **멀티쓰레딩의 장점**
  > - CPU의 사용률을 향상시킨다．
  > - 자원을 보다 효율적으로 사용할 수 있다．
  > - 사용자에 대한 응답성이 향상된다．
  > - 작업이 분리되어 코드가 간결해진다． 
  > 
  > 멀티쓰레딩이 가능함으로써 메신저로 파일을 다운로드하면서 채팅을 할 수 있게 된다.
  > 
  > **멀티쓰레딩의 단점**
  > 
  > - 동기화(synchronization)
  > - 교착상태(deadlock) : 두 쓰레드가 자원을 점유한 상태에서 서로 상대펀이 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태
  > 
  > 아래에서 싱글쓰레드와 멀티쓰레드의 차이점을 좀 더 자세히 보겠습니다.   
  

## 쓰레드의 구현과 실행
1. Thread클래스를 상속받는 방법
   -  다른 클래스를 상속받을 수 없다.
        ```java
        class MyThread extends Thread {
            public void run() { /* 작업내용 */ } // Thread클래스의 run(）을오버라이딩
        }
        ```
2. Runnable인터페이스를 구현하는 방법 
    - 재사용성(reusability)이 높고 코드의 일관성(consistency)을 유지할 수 있기 때문에 보다 객쳬지향적인 방법
        ```java
        class MyThread implements Runnable {
            public void run() { /* 작업내용 */ } // Runnable인터페이스의 run(）을구현
        } 
        
        ```
        > **Runnable인터페이스** : 오로지 run(）만 정의되어 있는 간단한 인터페이스
        > ```java
        > public interface Runnable {
        >     public abstract void runO;
        > }
        > ```
 
> ### Thread 클래스 상속 vs Runnable 인터페이스 구현
> ```java
> class ThreadExl {
>  public static void main(String args[]) {
>    //인스턴스 생성 방법이 다르다.
>    ThreadEx1_1 t1 = new ThreadEx1_1();
> 
>    Runnable r = new ThreadEx1_2();
>    Thread t2 = new Thread(r); // 생성자 Thread(Runnable target)
>    t1.start(); //start()를 하면 실행대기 상태로 있다가 자신의 차례가 오면 실행 
>    t2.start(); //-> 내부적으로 run() 수행
>    //한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다 
>    // = 하나의 쓰레드에 대해 start(）가 한 번만 호출될 수 있다
>    // 한 번 더 실행하려면 새로 생성해줘야함
>  }
> }
> class ThreadEx1_1 extends Thread {
>   public void run() {
>     for(int i=0; i < 5; i++) {
>       System.out.println (getName()); // 조상인 Thread의 getName()을 직접호출
>     }
>   }
> }
> class ThreadEx1_2 implements Runnable {
>   public void run() {
>     for(int i=0; i < 5; i++) {
>     // Thread. currentThread() - 현재실행중인 Thread를반환한다．
>     System.out.println(Thread.currentThread().getName()); 
>                             //쓰레드에 대한 참조를 얻어 와야 호출가능
>   }
>   }
> }
>```
> 
>- 결과<br>
>  ![img.png](images/result3.png) ![img_1.png](images/result2.png) ![img_2.png](images/result.png)
> 
> 
> - 참고) ![img.png](images/java_lang_Thread.png) 에 있는 소스코드
>    ![img_3.png](images/currentThread.png)<br>
>    ![img_2.png](images/thread_getName.png)<br>
>   ![img_3.png](images/Thread.png)<br>
>   ![img_4.png](images/Thread2.png)<br>
>   ![img.png](images/run.png) target : private Runnable target;<br>
>   ![img.png](images/start.png)



## run() vs start()
- run() : 단순 클래스의 선언된 메서드를 호출(생성된 쓰레드를 실행시키는 것이 아님)
- start() : 쓰레드 실행
    - 새로운 쓰레드가 작업을 실행하는데 필요한 **호출스택（call stack）을 생성**한 다음 
      run(）을 호출해서, 생성된 호출스택에 run(）이 첫 번째로 올라가게 한다.
      (쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요)
      ![img.png](images/call_stack.png)
    - 새로운 쓰레드를 생성하고 실행시킬 때마다 <br>새로운 호출스택이 생성되고 <br>쓰레드가 종료되면 작업에 사용된 호출스택은 소멸
    ![호출스택 변화](images/호출스택변화.png)
      > main메서드의 작업을 수행하는 것도 쓰레드
    
> 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다．  

## 싱글쓰레드 vs 멀티쓰레드
![img.png](images/singleTh-multiTh.png)</br>
1. 한 작업 마친 후 다른 작업 
2. 짧은 시간동안 두 개의 쓰레드가 번갈아 가면서 작업
> 두 경우 최종 수행 시간은 거의 같지만 쓰레드간의 작업 전환(context switching)에 시간이 걸려 두 개의 쓰레드로 작업한 시간이 더 오래 걸린다고한다.
> 
> > 작업을 전환할 때는 작업의 상태(다음에 실행할 위치 등)정보를 저장하고 읽는 시간이 소요된다고 합니다.

![img.png](images/th_concurrent_parallel.png)</br>
- 싱글 코어 일 경우, 두 작업이 겹치지 않음
- 멀티 코어 일 경우, 동시에 두 쓰레드가 수행될 수 있으므로 작업이 겹칠 수 있음
> 병행（concurrent) : 여러 쓰레드가 여러 작업을 동시에 진행</br>
> 병렬（parallel） : 하나의 작업을 여러 쓰레드가 나눠 처리

## 쓰레드의 우선순위
![img.png](images/priority.png)
![img.png](images/priority2.png)
- 작업의 중요도에 따라 쓰레드의 우선순위 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.
- 가질 수 있는 우선순위의 범위는 1-10
-  숫자가 높을수록 우선순위가 높음
- 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.
    </br>(main메서드를 수행하는 쓰레드는 우선순위가 5이므로 main메서드 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5)
  
## 쓰레드 그룹(thread group)
: 서로 **관련된 쓰레드**를 그룹으로 다루기 위한 것
- 보안상의 이유로 도입
- 모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함
    - 쓰레드 그룹을 지정하지 않고 생한한 쓰레드는 main쓰레드 그룹에 속함
      > ### 자바 어플리케이션이 실행되면
      > 1. 실행
      > 2. JVM이 `main`과 `system`이라는 쓰레드 그룹을 만듦
      > 3. JVM운영에 필요한 쓰레드들을 생성
      > 4. 각자 해당하는 쓰레드 그룹에 포함시킴
      > - ex) main쓰레드 - main쓰레드 그룹 / (가비지컬렉션을 수행하는)Finalizer쓰레드 - system쓰레드 그룹
    - 자신을 생성한 쓰레드의 그룹과 우선순위를 상속 받음.
- 자신이 속한 쓰레드 그룹 or 하위 쓰레드 그룹은 변경가능하지만 다른 쓰레드 그룹의 쓰레드는 변경 불가
- ThreadGroup의 생성자와 메서드</br>
    ![img_1.png](images/ThreadGroup.png)
- Thread 생성자를 이용해 쓰레드 그룹에 포함 시킬 수 있다.
    ![img_2.png](images/Thread_Constructor.png)
  
## 데몬 쓰레드(daemon thread)
: 다른 일반 쓰레드(데몬 쓰레드가 아닌 쓰레드）의 작업을 돕는 보조적 인 역할을 수행하는쓰레드
- 일반 쓰레드가 모두 종료되면 자동 종료
- 무한루프와 조건문을 이용해 실행 후 대기하다 특정 조건시 수행하고 다시 대기하도록 작성
- ex) 가비지 컬렉터, 자동저장, 화면자동갱신

## 쓰레드의 실행제어
- 쓰레드의 스케줄링과 관련된 메서드
    ![img.png](images/스레드스케쥴링.png)
    - resumeQ, stop(), suspend(）는 쓰레드를 교착상태（dead-Icc卞）로 만들기 쉽기 때문에 deprecated
- 쓰레드의 상태
    ![img.png](images/스레드상태.png)

- 쓰레드 생성부터 소멸까지의 상태변화
    ![img.png](images/스레드실행상태.png)
    
### `sleep(long millis)` - 일정시간동안 실행하는 쓰레드 멈춤
```java
static void sleep(long millis)
static void sleep(long millis, mnt nanos)
//밀리세컨드（millis, 1000분의 일초）와 나노세컨드（nanos, 10억분의 일초) 단위로 지정
```
- static으로 선언되어 있어 Thread.sleep(2000) 같이 선언해주는 것이 맞음
    - 특정 쓰레드를 지정해서 멈추게 하는 것은 불가능
- 호출할 때는 항상 try-catch문으로 예외를 처리해줘야 함

### `interrupt()` / `interrupted()` - 쓰레드 작업 취소
- 스레드가 일시 정지 상태일 때 InterruptedException 예외를 발생시키는 역할
- 진행 중인 쓰레드의 작업이 끝나기 전에 취소시켜야할 때 사용
    - ex) 큰 파일 다운로드 할 때 너무 오래 걸려 다운로드를 포기하고 취소
- 스레드가 일시 정지 상태가 되지 않는다면 interrupt() 메소드 호출은 아무런 의미가 없다.
    - 스레드가 실행 대기 또는 실행 상태에 있을 때 interrupt() 메소드가 실행되면 즉시 InterruptedException 예외가 발생하지 않고, 스레드가 미래에 일시 정지 상태가 되면 즉시 InterruptedException 예외가 발생
      참고 : https://ict-nroo.tistory.com/22
```java
void interrupt() // 쓰레드의 interrupted상태를 false에서 true로 변경．
boolean isInterrupted()// 쓰레드의 interrupted상태를반환．
static boolean interrupted() //현재쓰레드의 interrupted상태를반환후, false로 변경 
```
![img.png](images/interrupted.png)
- sleep()에 의해 쓰레드가 잠시 멈춰있을 때, interrupt()를 호출하면 InterruptedException 발생 (interrupted상태는 false로 자동 초기화)
    ```java
    try{
        Tread.sleep(1000);
    } catch(InterruptedException e){
        intrrupt(); // 추가해줘서 true로 바꾸기
    }
    ```
### suspend(), resume(), stop()
```java
void suspend() // 일시정지
void resume() // suspend()에 의해 일시정지된 쓰레드를 실행대기상태로
void stop() // 즉시 종료
```
- 교착상태（deadlock）를 일으키기 쉽게 작성
- deprecated 됨

### `yield()` - 다른 쓰레드에게 양보
- 남은 시간을 다음 쓰레드에게 양보하고 자신은 실행대기한다.
- yield()와 interrupt()를 적절히 사용시, 응답성과 효율을 높임.
    ```java
    while(!stopped){ //stop이 아닌상태에 실행
        if(!supended){ 
            //일시정치 아닌 상태
        }else{
            //일시정지인 상태 → while을 의미 없이 돌아 낭비!!!((busy-waiting)바쁜 대기상태라고함)
            Thread.yield(); // 다른쓰레드에게 양보 → 더 효율적
        }   
        
    }
    ```
```java
public void suspend(){
    suspended = true;
    th.interrupt(); // sleep()에서  InterruptedException이 발생하여 
                // 즉시 일시정지 상태에서 벗어나게 되므로 응답성이 좋아짐.
}
```
### `join()` - 다른 쓰레드의 작업을 기다린다．
- 쓰레드 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 기다림
    - `th1.join()` // 현재 실행하고 있는 쓰레드가 th1의 작업이 끝날때 까지 기다림
```java
void join() // 작업이 모두 끝날 때까지(시간을 지정하지 않으면 , 해당 쓰레드가 작업을 모두 마칠 때까지 기다림)
void join(long millis) // 천분의 일초 동안
void join(long millis, mnt nanos) // 천분의 일초 + 나노초 동안
```
- 작업 중 다른 쓰레드의 작업이 먼저 수행되어야할 필요가 있을 때 사용
- interrupt()에 의해 대기상태에서 벗어날 수 있어, try- catch문으로 감싸야 함
- join은 특정 쓰레드 기준 / sleep()은 현재 쓰레드(static 메서드) 기준
- main쓰레드가 th1 th2 작업이 마칠때 까지 기다림
  <br>(join()이 없으면 main쓰레드가 원래는 바로 종료)
    ![img_1.png](images/join.png)

## 쓰레드의 동기화(synchronization)
: 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것
- 한 번에 하나의 쓰레드만 객체에 접근할 수 있도록 객체에 락(lock)걸어서 데이터 일관성 유지하는 것
    > 1. 멀티쓰레드 프로세스는 여러 스레드가 자원 공유하며 작업
    > 2. 서로 영향 줌
    > 3. 의도와는 다른 결과 발생할 수 있음.
    > 4. 이를 방지하기 위해 한 스레드가 특정 작업을 마치기 전까지 방해받지 못하게 해야함
    > 5. 그래서 도입된 개념이 임계 영역(critical section)과 락(lock)!
    >   > 1. 공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정 
    >   > 2. 공유 데이터（객쳬)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 한다
    >   > 3. 해당 쓰레드가 코드를 수행하고 벗어나서 lock을 반납
    >   > 4. 다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행

### synchronized - 임계영역 설정
- lock의 획득과 반납이 모두 자동적으로 이루어지므로 우리는 임계 영역만 설정해주면 됨
    ```java
    public synchronized void calcSum(){} //메서드를 임계영역으로 지정
    synchronized(객체의 참조변수){} // 특정 객체를 임계영역으로 지정
    ```
- if문의 조건식을 통과하고 출금하기 바로 직전에 다른 쓰레드가 끼어들어서 출금    
    ![img.png](images/synchronized.png)
    
### wait() notify()
- 특정 쓰레드가 객쳬의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것도 중요
```java
//Object클래스에 정의되있음
//동기화 블록 내에서만 사용가능
void wait() //객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣음
void wait(long timeout)
void wait(long timeout, int nanos)
void notify() //waiting pool 에서 대기중인 쓰레드중 하나를 깨움
void notifyAll() //waiting pool 에서 대기중인 모든 쓰레드를 깨움
```

### Lock과 Condition을 이용한 동기화
- ' java.util.concurrent.locks' 패키지가 제공하는 lock클래스 이용




